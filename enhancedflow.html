<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mermaid Sequence Diagram Editor with Custom Actors</title>
  <style>
    * { box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    h1 {
      margin-top: 0;
      color: #333;
    }
    .section {
      margin-bottom: 25px;
    }
    .section h3 {
      margin-top: 0;
      color: #555;
      font-size: 16px;
    }
    textarea { 
      width: 100%; 
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      resize: vertical;
    }
    #code {
      height: 250px;
    }
    #actorConfig {
      height: 120px;
    }
    button { 
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 10px;
    }
    button:hover {
      background: #0056b3;
    }
    button.secondary {
      background: #6c757d;
    }
    button.secondary:hover {
      background: #545b62;
    }
    #diagram { 
      border: 1px solid #ddd; 
      margin-top: 20px; 
      padding: 20px;
      min-height: 300px;
      background: white;
      border-radius: 4px;
      overflow-x: auto;
    }
    .help-text {
      font-size: 13px;
      color: #666;
      margin-top: 5px;
    }
    .help-text code {
      background: #f5f5f5;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: #c7254e;
    }
    .example-link {
      color: #007bff;
      cursor: pointer;
      text-decoration: underline;
      font-size: 13px;
    }
    .example-link:hover {
      color: #0056b3;
    }
    .actor-image {
      border-radius: 50%;
    }
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .upload-section {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 15px;
    }
    .actor-upload-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    .actor-upload-row input[type="text"] {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .actor-upload-row input[type="file"] {
      flex: 2;
      font-size: 13px;
    }
    .actor-upload-row button {
      padding: 8px 12px;
      margin: 0;
    }
    .preview-images {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-top: 15px;
    }
    .preview-item {
      text-align: center;
    }
    .preview-item img {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid #ddd;
      display: block;
      margin-bottom: 5px;
    }
    .preview-item span {
      font-size: 12px;
      color: #666;
    }
    .button-small {
      padding: 6px 12px;
      font-size: 13px;
    }
    .error-box {
      background: #fee;
      border: 1px solid #fcc;
      border-radius: 4px;
      padding: 15px;
      margin: 15px 0;
      color: #c33;
    }
    .error-box h4 {
      margin: 0 0 10px 0;
      color: #a00;
    }
    .error-box pre {
      background: #fff;
      padding: 10px;
      border-radius: 3px;
      overflow-x: auto;
      font-size: 12px;
      margin: 10px 0 0 0;
    }
    .success-box {
      background: #efe;
      border: 1px solid #cfc;
      border-radius: 4px;
      padding: 10px 15px;
      margin: 15px 0;
      color: #060;
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üé® Mermaid Sequence Diagram Editor</h1>
    <p>Create sequence diagrams with custom actor images, spacing, and flow images</p>

    <div class="section">
      <h3>Upload Local Images</h3>
      <div class="upload-section">
        <div id="uploadRows">
          <div class="actor-upload-row">
            <input type="text" placeholder="Actor Name (e.g., consumer)" class="actor-name-input">
            <input type="file" accept="image/*" class="actor-image-input">
          </div>
        </div>
        <button class="button-small" onclick="addUploadRow()">+ Add Another Actor</button>
        <button class="button-small" onclick="processUploads()">üìÅ Load Images</button>
        <div class="preview-images" id="previewImages"></div>
      </div>
    </div>

    <div class="section">
      <h3>Actor Image Configuration (JSON)</h3>
      <textarea id="actorConfig" placeholder='{"Alice": "https://i.pravatar.cc/150?img=1", "Bob": "https://i.pravatar.cc/150?img=2"}'></textarea>
      <div class="help-text">
        Auto-generated from uploaded images, or enter URLs manually
      </div>
    </div>

    <div class="section">
      <h3>Flow Images (Optional)</h3>
      <div class="upload-section">
        <p style="margin: 0 0 10px 0; font-size: 14px;">Upload images to use in your flow (converts to data URLs automatically)</p>
        <div id="flowImageUploadRows">
          <div class="actor-upload-row">
            <input type="text" placeholder="Label (e.g., 'Token')" class="flow-label-input" style="flex: 1;">
            <input type="file" accept="image/*" class="flow-file-input" style="flex: 1;">
          </div>
        </div>
        <button class="button-small" onclick="addFlowImageUploadRow()">+ Add Another Image</button>
        <button class="button-small" onclick="processFlowImageUploads()">üì∑ Load Flow Images</button>
        <div class="preview-images" id="flowImagePreviews"></div>
        <div class="help-text" style="margin-top: 10px;">
          After loading, use in your code: <code>%%FLOWIMAGE: Label | {{Label}} | actor | position%%</code>
        </div>
      </div>
    </div>

    <div class="section">
      <h3>Mermaid Diagram Code</h3>
      <textarea id="code">sequenceDiagram
  participant consumer as Consumer
  participant ma as Mastercard
  consumer->>ma: Call#1
  %%FLOWIMAGE: üîê Auth | https://via.placeholder.com/80/4CAF50/FFF?text=Token | consumer | on%%
  ma->>consumer: Response#1</textarea>
      <div class="help-text">
        <strong>Custom syntax:</strong><br>
        ‚Ä¢ <code>%%SPACE: pixels%%</code> - Add vertical space<br>
        ‚Ä¢ <code>%%FLOWIMAGE: Label | imageUrl | alignment | position%%</code> - Insert image<br>
        <small>Alignment: <code>center</code>, <code>left</code>, <code>right</code>, or actor name</small><br>
        <small>Position: <code>between</code> (default), <code>on</code>, <code>leftOf:actor</code>, <code>rightOf:actor</code></small><br>
        <span class="example-link" onclick="showExample()">Show example with all features</span>
      </div>
    </div>

    <div class="controls">
      <button onclick="renderDiagram()">üé® Render Diagram</button>
      <button class="secondary" onclick="clearImages()">Clear Images</button>
      <button class="secondary" onclick="downloadSVG()">‚¨áÔ∏è Download SVG</button>
      <button class="secondary" onclick="downloadPNG()">‚¨áÔ∏è Download PNG</button>
      <label style="display: flex; align-items: center; gap: 8px; margin-left: 10px;">
        <input type="checkbox" id="showBottomActors" checked onchange="renderDiagram()">
        <span>Show actors at bottom</span>
      </label>
    </div>

    <div id="errorDisplay"></div>
    <div id="successDisplay" class="success-box"></div>
    <div id="diagram"></div>
  </div>

  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.esm.min.mjs';
    
    mermaid.initialize({ 
      startOnLoad: false,
      theme: 'default',
      sequence: {
        actorMargin: 80,
        width: 150,
        height: 100
      }
    });

    // Storage for uploaded flow images
    const uploadedFlowImages = {};

    window.addFlowImageUploadRow = function() {
      const flowImageUploadRows = document.getElementById('flowImageUploadRows');
      const newRow = document.createElement('div');
      newRow.className = 'actor-upload-row';
      newRow.innerHTML = `
        <input type="text" placeholder="Label (e.g., 'Receipt')" class="flow-label-input" style="flex: 1;">
        <input type="file" accept="image/*" class="flow-file-input" style="flex: 1;">
        <button onclick="this.parentElement.remove()">‚úï</button>
      `;
      flowImageUploadRows.appendChild(newRow);
    };

    window.processFlowImageUploads = async function() {
      const rows = document.querySelectorAll('#flowImageUploadRows .actor-upload-row');
      const previewContainer = document.getElementById('flowImagePreviews');
      
      previewContainer.innerHTML = '';
      
      if (rows.length === 0) {
        showError('Upload Error', 'No upload rows found.', null);
        return;
      }
      
      let hasValidUploads = false;
      
      for (const row of rows) {
        const labelInput = row.querySelector('.flow-label-input');
        const fileInput = row.querySelector('.flow-file-input');
        
        const label = labelInput.value.trim();
        const file = fileInput.files[0];
        
        if (label && file) {
          try {
            if (!file.type.startsWith('image/')) {
              showError('Invalid File Type', 
                `File "${file.name}" is not a valid image file.`,
                'Please upload PNG, JPG, GIF, or other image formats.');
              continue;
            }
            
            const dataUrl = await fileToDataUrl(file);
            uploadedFlowImages[label] = dataUrl;
            hasValidUploads = true;
            
            const previewItem = document.createElement('div');
            previewItem.className = 'preview-item';
            previewItem.innerHTML = `
              <img src="${dataUrl}" alt="${label}" style="border-radius: 4px;">
              <span>${label}</span>
            `;
            previewContainer.appendChild(previewItem);
          } catch (err) {
            showError('Upload Error', 
              `Error processing image for "${label}".`,
              err.message);
          }
        }
      }
      
      if (!hasValidUploads) {
        showError('No Valid Uploads', 
          'Please enter labels and select image files for each row.',
          null);
        return;
      }
      
      if (Object.keys(uploadedFlowImages).length > 0) {
        showSuccess(`‚úì Successfully loaded ${Object.keys(uploadedFlowImages).length} flow image(s)! Use {{Label}} as the URL in your code.`);
      }
    };

    window.renderDiagram = async function () {
      const code = document.getElementById('code').value;
      const actorConfigText = document.getElementById('actorConfig').value.trim();
      const diagram = document.getElementById('diagram');
      const errorDisplay = document.getElementById('errorDisplay');
      const successDisplay = document.getElementById('successDisplay');
      
      errorDisplay.innerHTML = '';
      successDisplay.style.display = 'none';
      
      let actorImages = {};
      
      if (actorConfigText) {
        try {
          actorImages = JSON.parse(actorConfigText);
        } catch (err) {
          showError('JSON Configuration Error', 
            'Invalid JSON in Actor Configuration. Please check your syntax.',
            err.message);
          return;
        }
      }
      
      const inlineFlowImages = parseInlineFlowImages(code);
      const inlineSpacings = parseInlineSpacing(code);
      
      if (!code.trim()) {
        showError('Empty Diagram', 
          'Please enter Mermaid diagram code.',
          'The code textarea is empty.');
        return;
      }
      
      try {
        const uniqueId = 'mermaidDiagram-' + Date.now();
        const { svg } = await mermaid.render(uniqueId, code);
        diagram.innerHTML = svg;
        
        if (Object.keys(actorImages).length > 0 || inlineFlowImages.length > 0 || inlineSpacings.length > 0) {
          setTimeout(() => {
            try {
              const svgElement = document.querySelector('#diagram svg');
              
              if (Object.keys(actorImages).length > 0) {
                applyCustomActorImages(actorImages);
              }
              
              if (svgElement && inlineSpacings.length > 0) {
                applyInlineSpacing(svgElement, inlineSpacings, code);
              }
              
              if (svgElement && inlineFlowImages.length > 0) {
                applyFlowImagesInline(svgElement, inlineFlowImages, code);
              }
              
              const totalCustomizations = Object.keys(actorImages).length + inlineFlowImages.length + inlineSpacings.length;
              showSuccess(`‚úì Diagram rendered with ${totalCustomizations} customization(s)!`);
            } catch (err) {
              showError('Customization Error', 
                'The diagram rendered, but there was an error applying customizations.',
                err.message);
            }
          }, 10);
        } else {
          showSuccess('‚úì Diagram rendered successfully!');
        }
      } catch (err) {
        showError('Mermaid Rendering Error', 
          'There was an error rendering your Mermaid diagram. Please check your syntax.',
          err.toString());
        diagram.innerHTML = '';
      }
    };

    function parseInlineFlowImages(mermaidCode) {
      const flowImagePattern = /%%FLOWIMAGE:\s*([^|]+)\s*\|\s*([^|]+?)(?:\s*\|\s*([^|]+?))?(?:\s*\|\s*(.+?))?%%/gi;
      const images = [];
      const lines = mermaidCode.split('\n');
      
      lines.forEach((line, lineIndex) => {
        const match = flowImagePattern.exec(line);
        if (match) {
          let imageUrl = match[2].trim();
          
          // Replace {{Label}} with uploaded image data URL
          const placeholderMatch = imageUrl.match(/\{\{(.+?)\}\}/);
          if (placeholderMatch) {
            const label = placeholderMatch[1].trim();
            if (uploadedFlowImages[label]) {
              imageUrl = uploadedFlowImages[label];
            } else {
              console.warn(`Flow image placeholder {{${label}}} not found in uploaded images`);
            }
          }
          
          images.push({
            label: match[1].trim(),
            imageUrl: imageUrl,
            alignment: match[3] ? match[3].trim() : 'center',
            position: match[4] ? match[4].trim() : 'between',
            lineNumber: lineIndex + 1
          });
        }
        flowImagePattern.lastIndex = 0;
      });
      
      return images;
    }

    function parseInlineSpacing(mermaidCode) {
      const spacingPattern = /%%SPACE:\s*(\d+)%%/gi;
      const spacings = [];
      const lines = mermaidCode.split('\n');
      
      lines.forEach((line, lineIndex) => {
        const match = spacingPattern.exec(line);
        if (match) {
          spacings.push({
            lineNumber: lineIndex + 1,
            height: parseInt(match[1])
          });
        }
        spacingPattern.lastIndex = 0;
      });
      
      return spacings;
    }

    function applyInlineSpacing(svg, spacings, mermaidCode) {
      if (spacings.length === 0) return;
      
      const codeLines = mermaidCode.split('\n');
      const messages = getAllMessagePositions(svg);
      
      const spacingAdjustments = spacings.map(spacing => {
        let messageCount = 0;
        
        for (let i = 0; i < spacing.lineNumber - 1 && i < codeLines.length; i++) {
          const line = codeLines[i].trim();
          if (line.match(/->>|-->>|->>/)) {
            messageCount++;
          }
        }
        
        return {
          afterMessage: messageCount,
          height: spacing.height
        };
      });
      
      const allPaths = svg.querySelectorAll('path, line');
      const allTexts = svg.querySelectorAll('text');
      const allRects = svg.querySelectorAll('rect');
      const allImages = svg.querySelectorAll('image');
      
      spacingAdjustments.forEach(adj => {
        if (adj.afterMessage > 0 && adj.afterMessage <= messages.length) {
          const cutoffY = messages[adj.afterMessage - 1].yPosition;
          
          shiftElements(allPaths, cutoffY, adj.height);
          shiftElements(allTexts, cutoffY, adj.height);
          shiftElements(allRects, cutoffY, adj.height);
          shiftElements(allImages, cutoffY, adj.height);
        }
      });
      
      const viewBox = svg.getAttribute('viewBox');
      if (viewBox) {
        const [minX, minY, width, height] = viewBox.split(' ').map(parseFloat);
        const totalSpacing = spacingAdjustments.reduce((sum, adj) => sum + adj.height, 0);
        const newHeight = height + totalSpacing;
        svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${newHeight}`);
      }
    }

    function shiftElements(elements, cutoffY, offset) {
      elements.forEach(el => {
        if (el.tagName === 'line') {
          const y1 = parseFloat(el.getAttribute('y1'));
          const y2 = parseFloat(el.getAttribute('y2'));
          if (y1 > cutoffY) el.setAttribute('y1', y1 + offset);
          if (y2 > cutoffY) el.setAttribute('y2', y2 + offset);
        } else if (el.tagName === 'path') {
          const d = el.getAttribute('d');
          if (d) {
            const newD = d.replace(/([MLHVCSQTAZmlhvcsqtaz])\s*([\d.-]+)[,\s]+([\d.-]+)/g, (match, cmd, x, y) => {
              const yNum = parseFloat(y);
              if (yNum > cutoffY) {
                return `${cmd} ${x},${yNum + offset}`;
              }
              return match;
            });
            el.setAttribute('d', newD);
          }
        } else if (el.tagName === 'text' || el.tagName === 'rect' || el.tagName === 'image') {
          const y = parseFloat(el.getAttribute('y'));
          if (y > cutoffY) el.setAttribute('y', y + offset);
        }
      });
    }

    function applyFlowImagesInline(svg, flowImages, mermaidCode) {
      if (flowImages.length === 0) return;
      
      const messages = getAllMessagePositions(svg);
      const actorPositions = getActorPositions(svg);
      const parBlocks = getParBlockBoundaries(svg);
      
      console.log(`=== Flow Image Placement ===`);
      console.log(`Total messages: ${messages.length}`);
      console.log(`Total par blocks detected: ${parBlocks.length}`);
      console.log(`Par blocks:`, parBlocks);
      
      const viewBox = svg.getAttribute('viewBox');
      let svgWidth = 400;
      let svgHeight = 300;
      let viewBoxMinX = 0, viewBoxMinY = 0;
      
      if (viewBox) {
        const [minX, minY, width, height] = viewBox.split(' ').map(parseFloat);
        svgWidth = width;
        svgHeight = height;
        viewBoxMinX = minX;
        viewBoxMinY = minY;
      }
      
      let maxFlowImageY = 0;
      
      flowImages.forEach(flowImage => {
        let yPosition;
        const codeLines = mermaidCode.split('\n');
        let messageCount = 0;
        
        // Count actual message lines, skip %%SPACE and %%FLOWIMAGE directives
        for (let i = 0; i < flowImage.lineNumber - 1 && i < codeLines.length; i++) {
          const line = codeLines[i].trim();
          
          // Skip our custom directives
          if (line.startsWith('%%SPACE:') || line.startsWith('%%FLOWIMAGE:')) {
            continue;
          }
          
          // Count message lines
          if (line.match(/->>|-->>|->>/)) {
            messageCount++;
          }
        }
        
        console.log(`Flow image "${flowImage.label}" at line ${flowImage.lineNumber} - messageCount: ${messageCount}, total messages: ${messages.length}`);
        
        if (messageCount > 0 && messageCount <= messages.length) {
          const message = messages[messageCount - 1];
          yPosition = message.yPosition;
          
          // Check if there's an 'end' statement right before the flowimage
          let linesBack = 1;
          let foundEnd = false;
          while (linesBack < 10 && flowImage.lineNumber - linesBack > 0) {
            const checkLine = codeLines[flowImage.lineNumber - 1 - linesBack].trim();
            if (checkLine === 'end') {
              foundEnd = true;
              break;
            }
            if (checkLine.startsWith('%%SPACE:') || checkLine.startsWith('%%FLOWIMAGE:') || checkLine === '') {
              linesBack++;
              continue;
            }
            break;
          }
          
          if (foundEnd) {
            console.log(`Found 'end' before flow image at Y=${yPosition}`);
            console.log(`Available par blocks:`, parBlocks);
            
            // Find the par block that contains this Y position
            // Be lenient - check if Y is within or just slightly after the block
            const containingBlock = parBlocks.find(block => 
              yPosition >= block.topY - 20 && yPosition <= block.bottomY + 80
            );
            
            if (containingBlock) {
              console.log(`Found containing par block: topY=${containingBlock.topY}, bottomY=${containingBlock.bottomY}`);
              yPosition = containingBlock.bottomY + 40; // Position well after the block
            } else {
              console.log(`No containing block found, adding standard spacing. Looking for block near Y=${yPosition}`);
              yPosition += 150; // Large extra space after block end
            }
          }
          
          // Adjust Y position based on position parameter
          if (flowImage.position === 'on') {
            yPosition = yPosition - 40; // On the message line
          } else {
            if (!foundEnd) {
              yPosition = yPosition + 30; // Between messages (default)
            }
          }
          
          insertFlowImage(svg, flowImage, yPosition, svgWidth, actorPositions);
          maxFlowImageY = Math.max(maxFlowImageY, yPosition + 120);
        } else {
          console.warn(`Could not place flow image "${flowImage.label}" - messageCount ${messageCount} out of range`);
        }
      });
      
      if (maxFlowImageY > svgHeight) {
        const newHeight = maxFlowImageY + 20;
        svg.setAttribute('viewBox', `${viewBoxMinX} ${viewBoxMinY} ${svgWidth} ${newHeight}`);
      }
    }

    function getActorPositions(svg) {
      const positions = {};
      const actorRects = svg.querySelectorAll('rect.actor-top');
      
      actorRects.forEach(rect => {
        const name = rect.getAttribute('name');
        const x = parseFloat(rect.getAttribute('x'));
        const width = parseFloat(rect.getAttribute('width'));
        const centerX = x + (width / 2);
        
        if (name) {
          positions[name] = { x, width, centerX };
          positions[name.toLowerCase()] = { x, width, centerX };
        }
      });
      
      const allTexts = svg.querySelectorAll('text');
      allTexts.forEach(text => {
        const label = text.textContent.trim();
        if (!label) return;
        
        const textX = parseFloat(text.getAttribute('x'));
        if (isNaN(textX)) return;
        
        let closestRect = null;
        let minDistance = Infinity;
        
        actorRects.forEach(rect => {
          const rectX = parseFloat(rect.getAttribute('x'));
          const rectWidth = parseFloat(rect.getAttribute('width'));
          const rectCenterX = rectX + (rectWidth / 2);
          const distance = Math.abs(textX - rectCenterX);
          
          if (distance < minDistance && distance < 100) {
            minDistance = distance;
            closestRect = rect;
          }
        });
        
        if (closestRect) {
          const x = parseFloat(closestRect.getAttribute('x'));
          const width = parseFloat(closestRect.getAttribute('width'));
          const centerX = x + (width / 2);
          
          positions[label] = { x, width, centerX };
          positions[label.toLowerCase()] = { x, width, centerX };
        }
      });
      
      return positions;
    }

    function getAllMessagePositions(svg) {
      const messages = [];
      const messagePaths = svg.querySelectorAll('path[class*="messageLine"], line[class*="messageLine"], path.messageLine0, path.messageLine1');
      
      messagePaths.forEach((path, index) => {
        let yPosition;
        
        if (path.tagName === 'line') {
          yPosition = parseFloat(path.getAttribute('y1'));
        } else if (path.tagName === 'path') {
          const d = path.getAttribute('d');
          const match = d.match(/M\s*([\d.]+)[,\s]+([\d.]+)/);
          if (match) {
            yPosition = parseFloat(match[2]);
          }
        }
        
        if (yPosition) {
          messages.push({ index: index + 1, yPosition });
        }
      });
      
      return messages;
    }

    function getParBlockBoundaries(svg) {
      const boundaries = [];
      
      // Look for all rectangles that could be par/loop/alt blocks
      // These are typically larger rectangles that span multiple actors
      const allRects = svg.querySelectorAll('rect');
      
      allRects.forEach(rect => {
        const width = parseFloat(rect.getAttribute('width'));
        const height = parseFloat(rect.getAttribute('height'));
        const y = parseFloat(rect.getAttribute('y'));
        const x = parseFloat(rect.getAttribute('x'));
        const classes = rect.getAttribute('class') || '';
        
        // Par blocks are typically wide rectangles (spanning actors) and reasonably tall
        // Skip actor boxes which are smaller and have specific classes
        if (width > 200 && height > 50 && !classes.includes('actor')) {
          const bottomY = y + height;
          boundaries.push({
            topY: y,
            bottomY: bottomY,
            height: height,
            width: width,
            x: x,
            classes: classes
          });
          console.log(`Found potential par block: Y=${y}, height=${height}, width=${width}, class="${classes}"`);
        }
      });
      
      return boundaries.sort((a, b) => a.topY - b.topY);
    }

    function insertFlowImage(svg, flowImage, yPosition, svgWidth, actorPositions) {
      const imageSize = 80;
      let imageX = (svgWidth - imageSize) / 2;
      let textX = svgWidth / 2;
      
      const alignment = flowImage.alignment || 'center';
      const position = flowImage.position || 'between';
      const alignmentKey = alignment.toLowerCase();
      
      // Handle leftOf:actor and rightOf:actor
      if (position.startsWith('leftOf:') || position.startsWith('rightOf:')) {
        const parts = position.split(':');
        const actorName = parts[1];
        const actorPos = actorPositions[actorName] || actorPositions[actorName.toLowerCase()];
        
        if (actorPos) {
          // Position relative to actor's center line (vertical line down the middle)
          const halfImageSize = imageSize / 2;
          const offset = 45; // Distance from center line
          
          if (position.startsWith('leftOf:')) {
            imageX = actorPos.centerX - halfImageSize - offset;
            textX = imageX + halfImageSize;
          } else {
            imageX = actorPos.centerX + offset - halfImageSize;
            textX = imageX + halfImageSize;
          }
        }
      }
      // Handle regular alignment
      else if (alignmentKey !== 'center' && alignmentKey !== 'left' && alignmentKey !== 'right' && actorPositions[alignmentKey]) {
        const actorPos = actorPositions[alignmentKey];
        imageX = actorPos.centerX - (imageSize / 2);
        textX = actorPos.centerX;
      } else if (alignmentKey === 'left') {
        imageX = 10;
        textX = 10 + (imageSize / 2);
      } else if (alignmentKey === 'right') {
        imageX = svgWidth - imageSize - 10;
        textX = svgWidth - (imageSize / 2) - 10;
      }
      
      const imageY = yPosition;
      
      const border = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      border.setAttribute('x', imageX - 5);
      border.setAttribute('y', imageY - 5);
      border.setAttribute('width', imageSize + 10);
      border.setAttribute('height', imageSize + 10);
      border.setAttribute('fill', 'white');
      border.setAttribute('fill-opacity', '0.95');
      border.setAttribute('stroke', '#666');
      border.setAttribute('stroke-width', '2');
      border.setAttribute('rx', '4');
      
      const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
      image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', flowImage.imageUrl);
      image.setAttribute('x', imageX);
      image.setAttribute('y', imageY);
      image.setAttribute('width', imageSize);
      image.setAttribute('height', imageSize);
      image.setAttribute('class', 'flow-custom-image');
      
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.textContent = flowImage.label;
      text.setAttribute('x', textX);
      text.setAttribute('y', imageY + imageSize + 15);
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('class', 'flow-image-label');
      text.style.fontSize = '11px';
      text.style.fill = '#666';
      text.style.fontWeight = 'bold';
      
      svg.appendChild(border);
      svg.appendChild(image);
      svg.appendChild(text);
    }

    function showError(title, message, details) {
      const errorDisplay = document.getElementById('errorDisplay');
      errorDisplay.innerHTML = `
        <div class="error-box">
          <h4>‚ùå ${title}</h4>
          <p>${message}</p>
          ${details ? `<pre>${escapeHtml(details)}</pre>` : ''}
        </div>
      `;
      console.error(title + ':', details);
    }

    function showSuccess(message) {
      const successDisplay = document.getElementById('successDisplay');
      successDisplay.textContent = message;
      successDisplay.style.display = 'block';
      
      setTimeout(() => {
        successDisplay.style.display = 'none';
      }, 3000);
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    window.showExample = function() {
      const exampleCode = `sequenceDiagram
  participant User
  participant API
  participant Database
  
  User->>API: Login Request
  %%SPACE: 40%%
  %%FLOWIMAGE: üîê Token | https://via.placeholder.com/80/4CAF50/FFF?text=Auth | User | on%%
  %%SPACE: 40%%
  
  API->>Database: Query User
  %%FLOWIMAGE: üìä Cache | https://via.placeholder.com/80/2196F3/FFF?text=Data | left | leftOf:API%%
  
  Database-->>API: User Data
  %%FLOWIMAGE: ‚úì Valid | https://via.placeholder.com/80/FF9800/FFF?text=OK | right | rightOf:Database%%
  
  API-->>User: Login Success`;
      
      document.getElementById('code').value = exampleCode;
      showSuccess('‚úì Example loaded! Upload your own images and use {{Label}} placeholders.');
    };

    function applyCustomActorImages(actorImages) {
      const svg = document.querySelector('#diagram svg');
      if (!svg) {
        console.error('No SVG found!');
        return;
      }

      const showBottomActors = document.getElementById('showBottomActors').checked;
      const actorRects = svg.querySelectorAll('rect.actor-top');
      
      const nameToLabel = new Map();
      const allTexts = svg.querySelectorAll('text');
      allTexts.forEach(text => {
        const label = text.textContent.trim();
        const rects = svg.querySelectorAll('rect.actor-top, rect.actor-bottom');
        rects.forEach(rect => {
          const rectX = parseFloat(rect.getAttribute('x'));
          const rectWidth = parseFloat(rect.getAttribute('width'));
          const textX = parseFloat(text.getAttribute('x'));
          
          if (textX >= rectX && textX <= rectX + rectWidth) {
            const internalName = rect.getAttribute('name');
            if (internalName && !nameToLabel.has(internalName)) {
              nameToLabel.set(internalName, label);
            }
          }
        });
      });
      
      const processedActors = new Set();
      const actorLineAdjustments = new Map();
      
      actorRects.forEach((rect, index) => {
        const actorName = rect.getAttribute('name');
        const displayLabel = nameToLabel.get(actorName) || actorName;
        
        if (!actorName || processedActors.has(actorName)) return;
        
        let imageUrl = actorImages[actorName] || actorImages[displayLabel];
        if (!imageUrl) return;
        
        processedActors.add(actorName);
        
        const x = parseFloat(rect.getAttribute('x'));
        const y = parseFloat(rect.getAttribute('y'));
        const width = parseFloat(rect.getAttribute('width'));
        const height = parseFloat(rect.getAttribute('height'));
        
        rect.style.display = 'none';
        
        const imageSize = 60;
        const imageX = x + (width - imageSize) / 2;
        const imageY = y + 5;
        const textY = imageY + imageSize + 18;
        const textX = x + width / 2;
        const lineStartY = textY + 20;
        
        createActorImageAndText(svg, displayLabel, imageUrl, imageX, imageY, imageSize, textX, textY, index, 'top');
        
        actorLineAdjustments.set(actorName, { 
          startY: lineStartY,
          endY: null
        });
        
        const bottomRects = svg.querySelectorAll('rect.actor-bottom');
        bottomRects.forEach(bottomRect => {
          if (bottomRect.getAttribute('name') === actorName) {
            bottomRect.style.display = 'none';
            
            if (showBottomActors) {
              const bottomX = parseFloat(bottomRect.getAttribute('x'));
              const bottomY = parseFloat(bottomRect.getAttribute('y'));
              const bottomWidth = parseFloat(bottomRect.getAttribute('width'));
              const extraMargin = 30;
              
              const bottomTextY = bottomY + height - 5 + extraMargin;
              const bottomImageY = bottomTextY - 18 - imageSize;
              const bottomImageX = bottomX + (bottomWidth - imageSize) / 2;
              const bottomTextX = bottomX + bottomWidth / 2;
              const lineEndY = bottomImageY - 10;
              
              createActorImageAndText(svg, displayLabel, imageUrl, bottomImageX, bottomImageY, imageSize, bottomTextX, bottomTextY, index, 'bottom');
              
              const adjustment = actorLineAdjustments.get(actorName);
              if (adjustment) {
                adjustment.endY = lineEndY;
              }
            }
          }
        });
      });
      
      const textElements = svg.querySelectorAll('text');
      textElements.forEach(textElement => {
        if (textElement.classList.contains('actor-custom-text-top') || 
            textElement.classList.contains('actor-custom-text-bottom')) {
          return;
        }
        
        const textContent = textElement.textContent.trim();
        processedActors.forEach(actorName => {
          const displayLabel = nameToLabel.get(actorName) || actorName;
          if (textContent === displayLabel) {
            textElement.style.display = 'none';
          }
        });
      });
      
      const actorLines = svg.querySelectorAll('line.actor-line');
      actorLines.forEach(line => {
        const lineName = line.getAttribute('name');
        const adjustment = actorLineAdjustments.get(lineName);
        
        if (adjustment) {
          const originalY2 = parseFloat(line.getAttribute('y2'));
          line.setAttribute('y1', adjustment.startY);
          
          if (showBottomActors && adjustment.endY !== null) {
            line.setAttribute('y2', adjustment.endY);
          } else {
            const extendedY2 = originalY2 + 20;
            line.setAttribute('y2', extendedY2);
          }
        }
      });
      
      if (showBottomActors && processedActors.size > 0) {
        const viewBox = svg.getAttribute('viewBox');
        if (viewBox) {
          const [minX, minY, width, height] = viewBox.split(' ').map(parseFloat);
          const newHeight = height + 30;
          svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${newHeight}`);
        }
      }
    }

    function createActorImageAndText(svg, actorName, imageUrl, imageX, imageY, imageSize, textX, textY, index, position) {
      const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
      image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', imageUrl);
      image.setAttribute('x', imageX);
      image.setAttribute('y', imageY);
      image.setAttribute('width', imageSize);
      image.setAttribute('height', imageSize);
      image.setAttribute('class', `actor-custom-image-${position}`);
      
      const clipId = `clip-${actorName.replace(/\s/g, '-')}-${position}-${Date.now()}-${index}`;
      let defs = svg.querySelector('defs');
      if (!defs) {
        defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        svg.insertBefore(defs, svg.firstChild);
      }
      
      const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
      clipPath.setAttribute('id', clipId);
      
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', imageX + imageSize / 2);
      circle.setAttribute('cy', imageY + imageSize / 2);
      circle.setAttribute('r', imageSize / 2);
      
      clipPath.appendChild(circle);
      defs.appendChild(clipPath);
      image.setAttribute('clip-path', `url(#${clipId})`);
      
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.textContent = actorName;
      text.setAttribute('y', textY);
      text.setAttribute('x', textX);
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('class', `actor-custom-text-${position}`);
      text.style.fontWeight = '600';
      text.style.fontSize = '14px';
      text.style.fill = '#333';
      text.style.fontFamily = 'Arial, sans-serif';
      
      svg.appendChild(image);
      svg.appendChild(text);
    }

    window.clearImages = function() {
      document.getElementById('actorConfig').value = '';
      document.getElementById('previewImages').innerHTML = '';
      renderDiagram();
      showSuccess('‚úì Images cleared!');
    };

    window.downloadSVG = function() {
      const svg = document.querySelector('#diagram svg');
      if (!svg) {
        showError('Download Error', 'Please render a diagram first before downloading!', null);
        return;
      }
      
      try {
        const svgClone = svg.cloneNode(true);
        const serializer = new XMLSerializer();
        let svgString = serializer.serializeToString(svgClone);
        svgString = '<?xml version="1.0" encoding="UTF-8"?>\n' + svgString;
        
        const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'sequence-diagram.svg';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        showSuccess('‚úì SVG downloaded successfully!');
      } catch (err) {
        showError('Download Error', 'Failed to download SVG file.', err.message);
      }
    };

    window.downloadPNG = function() {
      const svg = document.querySelector('#diagram svg');
      if (!svg) {
        showError('Download Error', 'Please render a diagram first before downloading!', null);
        return;
      }
      
      try {
        const images = svg.querySelectorAll('image');
        const imageLoadPromises = Array.from(images).map(img => {
          return new Promise((resolve) => {
            const href = img.getAttribute('href') || img.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
            if (!href) {
              resolve();
              return;
            }
            
            const testImg = new Image();
            testImg.onload = () => resolve();
            testImg.onerror = () => resolve();
            testImg.src = href;
          });
        });
        
        Promise.all(imageLoadPromises).then(() => {
          convertSVGtoPNG(svg);
        });
        
      } catch (err) {
        showError('Download Error', 'Failed to download PNG file.', err.message);
      }
    };

    function convertSVGtoPNG(svg) {
      try {
        const svgRect = svg.getBoundingClientRect();
        const svgWidth = svgRect.width;
        const svgHeight = svgRect.height;
        
        const canvas = document.createElement('canvas');
        const scale = 2;
        canvas.width = svgWidth * scale;
        canvas.height = svgHeight * scale;
        const ctx = canvas.getContext('2d');
        ctx.scale(scale, scale);
        
        const svgClone = svg.cloneNode(true);
        const serializer = new XMLSerializer();
        let svgString = serializer.serializeToString(svgClone);
        
        if (!svgString.includes('xmlns')) {
          svgString = svgString.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
        }
        
        const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        
        const img = new Image();
        img.onload = function() {
          try {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, svgWidth, svgHeight);
            ctx.drawImage(img, 0, 0, svgWidth, svgHeight);
            
            canvas.toBlob(function(blob) {
              const pngUrl = URL.createObjectURL(blob);
              const link = document.createElement('a');
              link.href = pngUrl;
              link.download = 'sequence-diagram.png';
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(pngUrl);
              URL.revokeObjectURL(url);
              
              showSuccess('‚úì PNG downloaded successfully!');
            }, 'image/png');
          } catch (err) {
            showError('PNG Conversion Error', 'Failed to convert diagram to PNG.', err.message);
            URL.revokeObjectURL(url);
          }
        };
        
        img.onerror = function() {
          showError('PNG Conversion Error', 
            'Error converting to PNG. This may be due to external image URLs causing CORS issues.',
            'Try using local images or download as SVG instead.');
          URL.revokeObjectURL(url);
        };
        
        img.src = url;
      } catch (err) {
        showError('Conversion Error', 'Failed to convert to PNG.', err.message);
      }
    }

    window.addUploadRow = function() {
      const uploadRows = document.getElementById('uploadRows');
      const newRow = document.createElement('div');
      newRow.className = 'actor-upload-row';
      newRow.innerHTML = `
        <input type="text" placeholder="Actor Name (e.g., mastercard)" class="actor-name-input">
        <input type="file" accept="image/*" class="actor-image-input">
        <button onclick="this.parentElement.remove()">‚úï</button>
      `;
      uploadRows.appendChild(newRow);
    };

    window.processUploads = async function() {
      const rows = document.querySelectorAll('.actor-upload-row');
      const actorImages = {};
      const previewContainer = document.getElementById('previewImages');
      const errorDisplay = document.getElementById('errorDisplay');
      
      previewContainer.innerHTML = '';
      errorDisplay.innerHTML = '';
      
      if (rows.length === 0) {
        showError('Upload Error', 'No upload rows found. Click "+ Add Another Actor" to add images.', null);
        return;
      }
      
      let hasValidUploads = false;
      
      for (const row of rows) {
        const nameInput = row.querySelector('.actor-name-input');
        const fileInput = row.querySelector('.actor-image-input');
        
        const actorName = nameInput.value.trim();
        const file = fileInput.files[0];
        
        if (actorName && file) {
          try {
            if (!file.type.startsWith('image/')) {
              showError('Invalid File Type', 
                `File "${file.name}" is not a valid image file.`,
                'Please upload PNG, JPG, GIF, or other image formats.');
              continue;
            }
            
            const dataUrl = await fileToDataUrl(file);
            actorImages[actorName] = dataUrl;
            hasValidUploads = true;
            
            const previewItem = document.createElement('div');
            previewItem.className = 'preview-item';
            previewItem.innerHTML = `
              <img src="${dataUrl}" alt="${actorName}">
              <span>${actorName}</span>
            `;
            previewContainer.appendChild(previewItem);
          } catch (err) {
            showError('Upload Error', 
              `Error processing image for "${actorName}".`,
              err.message);
          }
        }
      }
      
      if (!hasValidUploads) {
        showError('No Valid Uploads', 
          'Please enter actor names and select image files for each row.',
          null);
        return;
      }
      
      if (Object.keys(actorImages).length > 0) {
        document.getElementById('actorConfig').value = JSON.stringify(actorImages, null, 2);
        showSuccess(`‚úì Successfully loaded ${Object.keys(actorImages).length} image(s)!`);
        renderDiagram();
      }
    };

    function fileToDataUrl(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // Initial render
    renderDiagram();
  </script>
</body>
</html>
